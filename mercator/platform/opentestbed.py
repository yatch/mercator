"""https://github.com/openwsn-berkeley/opentestbed
"""

import base64
import binascii
import json
import logging
import os
import queue
import threading
import time
import sys

import paho.mqtt.client as mqtt
import yaml

import mercator.node
import mercator.platform
from mercator.utils import print_bold, MercatorHalo, OSName

class Platform(mercator.platform.Platform):
    GET_ALL_NODES_TIMEOUT_SECONDS = 2

    def __init__(self, config, program_firmware):
        self.config = config

        # initialize MQTT client
        self.mqtt = self._init_mqtt_client(config['mqtt_broker'],
                                           config['token'])

        self.nodes = self._init_nodes(config['nodes'])

        self.firmware_os_name = OSName(config['firmware']['os'].lower())
        if program_firmware:
            self._program_firmware(config['firmware'])

        # make sure all the nodes have a firmware having the same name
        # as specified in config, and they booted successfully.
        self._check_firmware_status(config['firmware'])

    def setup_measurement(self, config):
        self._setup_nodes(config)
        return self.nodes

    @staticmethod
    def _dump_config_platform():
        config = {}
        config['name'] = 'opentestbed'
        config['mqtt_broker'] = {}
        config['mqtt_broker']['host'] = 'mqtt-broker.example.com'
        config['mqtt_broker']['port'] = 1883
        config['token'] = 123
        config['nodes'] = ['xx-xx-xx-xx-xx-xx-xx-xx',
                           'yy-yy-yy-yy-yy-yy-yy-yy',
                           'zz-zz-zz-zz-zz-zz-zz-zz']
        config['firmware'] = {}
        config['firmware']['os'] = 'OpenWSN'
        config['firmware']['path'] = 'firmwares/openwsn-openmote-b-24ghz.ihex'

        print(yaml.dump({'platform': config}, default_flow_style=False))

    def _init_mqtt_client(self, mqtt_broker_config, token):
        spinner = MercatorHalo(text='Initializing MQTT client')
        mqtt = MQTTClient(mqtt_broker_config, token)
        spinner.stop_success()
        return mqtt

    def _init_nodes(self, node_id_list):
        spinner = MercatorHalo(text='Initializing Mercator nodes')

        # get all the available motes in the opentestbed
        available_node_list = self._get_available_node_list()

        # confirm the nodes specified in config are listed in the
        # list; and create a Node object
        nodes = []
        unavailable_nodes = []
        otbox_set = set()
        for node_id in node_id_list:
            if node_id not in available_node_list:
                unavailable_nodes.append(node_id)
            else:
                node_info = available_node_list[node_id]
                mote = node_info['mote']
                otbox_id = node_info['otbox_id']

                node = Node(self, node_id, otbox_id)
                node.update_firmware_status((mote['firmware_description'],
                                             mote['bootload_success']))
                otbox_set.add(otbox_id)
                nodes.append(node)

        if unavailable_nodes:
            spinner.stop_failure()
            for node_id in unavailable_nodes:
                print_bold('Node {0} is not available'.format(node_id))
            print('Check the testbed status')
            exit(1)

        # reset the serial connections of each otbox, which can be
        # done by "discovermotes"
        for otbox_id in otbox_set:
            self._reset_serial_connections(otbox_id)

        spinner.stop_success()
        return nodes

    def _get_available_node_list(self):
        # 'dicovery' cmd doesn't work for some reason. use 'status'
        # instead
        cmd_topic = 'opentestbed/deviceType/box/deviceId/all/cmd/status'
        resp_topic = 'opentestbed/deviceType/box/deviceId/+/resp/status'

        node_list = {}  # indexed by node_id (EUI64)

        self.mqtt.subscribe(resp_topic)
        self.mqtt.send(cmd_topic)
        while True:
            payload = self.mqtt.recv(resp_topic,
                                            self.GET_ALL_NODES_TIMEOUT_SECONDS)
            if payload:
                try:
                    node_list.update(
                        {
                            mote['EUI64']: {
                                'mote': mote,
                                'otbox_id': payload['returnVal']['host_name']}
                            for mote in payload['returnVal']['motes']})
                except KeyError as err:
                    assert 'EUI64' in str(err)
                    # this otbox doesn't return any mote info; ignore this
                    continue
            else:
                break
        self.mqtt.unsubscribe(resp_topic)
        return node_list

    def _reset_serial_connections(self, otbox_id):
        topic_prefix = ('opentestbed/deviceType/box/deviceId/'
                        + '{0}'.format(otbox_id))
        cmd_topic = topic_prefix + '/cmd/status'
        resp_topic = topic_prefix + '/resp/status'

        self.mqtt.subscribe(resp_topic)
        self.mqtt.send(cmd_topic)
        payload = self.mqtt.recv(resp_topic)
        self.mqtt.unsubscribe(resp_topic)
        assert payload['success']

    def _program_firmware(self, firmware_config):
        spinner = MercatorHalo(text='Programming the firmware')

        firmware_path = firmware_config['path']
        assert os.path.exists(firmware_path)
        if firmware_config['os'].lower() == OSName.OpenWSN:
            assert os.path.basename(firmware_path).endswith('.ihex')

        firmware_image = b''
        with open(firmware_path, 'rb') as f:
            while True:
                chunk = f.read()
                if chunk:
                    # encode chunk into Base64
                    firmware_image += base64.encodebytes(chunk)
                else:
                    break

        # json.dumps() doesn't accept bytes object; needs to convert
        # to string
        firmware_hex_string = firmware_image.decode('utf-8') # string
        # remove all new line characters, which are inserted by
        # base64.decode(), because opentestbed doesn't accept a
        # firmware hex string having them
        firmware_hex_string = firmware_hex_string.replace('\n', '')
        firmware_name = os.path.basename(firmware_path)
        threads = []
        for node in self.nodes:
            thread = threading.Thread(target=node.program_firmware,
                                      args=(firmware_name,
                                            firmware_hex_string))
            thread.start()
            threads.append(thread)

        # wait until all the thread terminate
        for thread in threads:
            thread.join()

        if [node for node in self.nodes if not node.boot_success]:
            spinner.stop_failure()
            print_bold('Programming the firmware failed; check logs')
            exit(1)
        spinner.stop_success()

    def _check_firmware_status(self, firmware_config):
        spinner = MercatorHalo(text='Checking firmwares of the nodes')
        firmware_name = os.path.basename(firmware_config['path'])

        exit_on_failure = False
        for node in self.nodes:
            if node.firmware_status[0] != firmware_name:
                spinner.stop_failure()
                print_bold(
                    'Node {0} doesn\'t have the right firmware'.format(node.id))
                print_bold(
                    'Its firmware is "{0}"'.format(node.firmware_status[0]
                                                   if node.firmware_status[0]
                                                   else 'unknown'))
                exit_on_failure = True
            elif not node.firmware_status[1]:  # bootload_success
                spinner.stop_failure()
                print_bold(
                    'Node {0} failed to boot'.format(node.id))
                exit_on_failure = True

            if exit_on_failure:
                print('Try again with "-p" option to program the firmware')
                exit(1)

        spinner.stop_success()

    def _setup_nodes(self, config):
        spinner = MercatorHalo(text='Setting up nodes')
        threads = []
        for node in self.nodes:
            thread = threading.Thread(target=node.setup, args=(config,))
            thread.start()
            threads.append(thread)
        for thread in threads:
            thread.join()
        spinner.stop_success()

class Node(mercator.node.Node):
    MQTT_TOPIC_BASE='opentestbed/deviceType/mote/deviceId/'
    PROGRAM_TIMEOUT_SECONDS = 30
    PROGRAM_MAX_RETRY_COUNT = 2
    PROGRAM_WAIT_SECONDS = 15

    def __init__(self, platform, mac_addr, otbox_id):
        super(Node, self).__init__(platform)

        self.platform = platform
        self.id = mac_addr  # use mac_addr as id
        self.otbox_id = otbox_id
        self.mqtt_topic_prefix = self.MQTT_TOPIC_BASE + '{0}/'.format(self.id)
        self.firmware_status = (None, None)
        self.boot_success = None  # this is used in program_firmware()

        _prefix = 'opentestbed/deviceType/mote/deviceId/{0}'.format(self.id)
        self.topic_recv_msg = (_prefix
                               + '/notif/frommoteserialbytes')
        self.topic_send_msg = (_prefix
                               + '/cmd/tomoteserialbytes')
        self.topic_send_msg_resp = (_prefix
                                    + '/resp/tomoteserialbytes')

    def program_firmware(self, firmware_name, firmware_hex_image):
        retry_count = 0
        self.boot_success = False
        while retry_count <= self.PROGRAM_MAX_RETRY_COUNT:
            logging.info('Start programming "{0}" to {1}'.format(firmware_name,
                                                                 self.id))
            payload = self._send_mqtt_cmd('program',
                                          {'description': firmware_name,
                                           'hex': firmware_hex_image},
                                          self.PROGRAM_TIMEOUT_SECONDS)

            if payload and ('returnVal' in payload):
                self.update_firmware_status((firmware_name,
                                             payload['returnVal']))
                self.boot_success = True
                break
            else:
                logging.error('Failed to program '
                              + '"{0}" to {1} '.format(firmware_name, self.id))
                print(payload, file=sys.stderr)
                time.sleep(self.PROGRAM_WAIT_SECONDS)
                logging.error('Retry to program '
                              + '"{0}" to {1} '.format(firmware_name, self.id)
                              + 'in {0} '.format(self.PROGRAM_WAIT_SECONDS)
                              + 'seconds')
                retry_count += 1

        if self.boot_success:
            logging.info('Succeed to program '
                         + '"{0}" to {1}'.format(firmware_name, self.id))
        else:
            logging.critical('Failed to program '
                             + '"{0}" to {1}'.format(firmware_name, self.id))
            # the main program will terminate later

    def update_firmware_status(self, status):
        self.firmware_status = status

    def _setup(self):
        # subscribe the topic to receive serial bytes from the node
        self.platform.mqtt.subscribe(self.topic_recv_msg)
        self.platform.mqtt.subscribe(self.topic_send_msg_resp)

    def _am_i_tx_node(self, tx_nodes):
        return self.id in tx_nodes

    def _send_mqtt_cmd(self, cmd, payload={}, timeout=None):
        cmd_topic = self.mqtt_topic_prefix + 'cmd/{0}'.format(cmd)
        resp_topic = self.mqtt_topic_prefix + 'resp/{0}'.format(cmd)

        self.platform.mqtt.subscribe(resp_topic)
        self.platform.mqtt.send(cmd_topic, payload)
        payload = self.platform.mqtt.recv(resp_topic, timeout)
        self.platform.mqtt.unsubscribe(resp_topic)
        return payload

    def _platform_send(self, msg):
        # clear recv_queue for topic_send_msg_resp, which may have a
        # delayed response for the previous command
        self.platform.mqtt.clear_msg_queue(self.topic_send_msg_resp)
        self.platform.mqtt.send(self.topic_send_msg,
                                    {'serialbytes': [b for b in msg]})
        payload = self.platform.mqtt.recv(self.topic_send_msg_resp)
        if payload:
            assert payload['success'] is True
        else:
            err_str = ('No ACK from '
                       + '{0}/resp/tomoteserialbytes'.format(self.id))
            logging.error(err_str)
            logging.error('{0} may be busy'.format(self.otbox_id))

    def _platform_recv(self):
        payload = self.platform.mqtt.recv(self.topic_recv_msg)
        if payload and ('serialbytes' in payload):
            data = bytes(payload['serialbytes'])
        else:
            data = b''
        return data

class MQTTClient(object):
    MQTT_CLIENT_ID = 'mercator'
    DEFAULT_RECV_TIMEOUT_SECONDS = 5

    def __init__(self, mqtt_broker_config, token):
        self.token = token

        self._topics_of_interest = []
        # they are indexed by topic
        self._msg_queues = {}

        def _on_message(client, userdata, msg):
            matched_topics = [topic
                              for topic in self._topics_of_interest
                              if mqtt.topic_matches_sub(topic, msg.topic)]
            assert len(matched_topics) == 1
            topic = matched_topics[0]
            assert topic in self._msg_queues
            assert msg.payload
            self._msg_queues[topic].put(msg.payload)

        self._client = mqtt.Client(client_id=self.MQTT_CLIENT_ID)
        self._client.connect(host=mqtt_broker_config['host'],
                                 port=mqtt_broker_config['port'])
        self._client.on_message = _on_message
        self._client.enable_logger()
        self._client.loop_start()

    def send(self, topic, payload={}):
        # subscribe first to receive results
        if 'token' not in payload:
            # create a new dict having token
            payload = dict(token=self.token, **payload)
        payload_str = json.dumps(payload)
        ret = self._client.publish(topic, payload_str)
        logging.debug('Publish MQTT message to {0} '.format(topic)
                      + '{0}'.format(payload_str))
        assert ret.rc == mqtt.MQTT_ERR_SUCCESS

    def recv(self, topic, timeout=None):
        assert topic in self._topics_of_interest
        assert topic in self._msg_queues

        if not timeout:
            timeout = self.DEFAULT_RECV_TIMEOUT_SECONDS

        logging.debug('Wait on {0}'.format(topic))
        try:
            ret_msg = self._msg_queues[topic].get(timeout=timeout)
            logging.debug('Recv MQTT Payload on {0}: '.format(topic)
                          + '{0}'.format(ret_msg))
            ret_msg = json.loads(ret_msg)  # convert to dict
        except queue.Empty:
            # timeout
            logging.debug('Recv MQTT timeout on {0}'.format(topic))
            ret_msg = {}  # return an empty dict

        return ret_msg

    def clear_msg_queue(self, topic):
        while True:
            try:
                self._msg_queues[topic].get_nowait()
            except queue.Empty:
                # msg_queue is empty now
                break

    def subscribe(self, topic):
        assert topic not in self._topics_of_interest
        assert topic not in self._msg_queues
        # initialize internal variables for the topic
        self._topics_of_interest.append(topic)
        self._msg_queues[topic] = queue.SimpleQueue()
        self._client.subscribe(topic)
        logging.debug('Subscribe to {0}'.format(topic))

    def unsubscribe(self, topic):
        # initialize internal variables
        self._client.unsubscribe(topic)

        # a waiting thread will end with timeout
        assert topic in self._msg_queues
        del self._msg_queues[topic]

        self._topics_of_interest.remove(topic)
        logging.debug('Unsubscribe from {0}'.format(topic))

    def extract_device_id(self, topic):
        # topic looks like:
        # opentestbed/deviceType/box/deviceId/otbox17/cmd/status
        components = topic.split('/')
        assert len(components) == 7
        return components[4]
